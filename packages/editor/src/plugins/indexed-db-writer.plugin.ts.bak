import { Plugin, PluginKey } from "prosemirror-state";
import { Step, StepMap, Transform } from "prosemirror-transform";
import { nanoid } from "nanoid";

interface Commit {
  id: string;
  time: number;
  steps: Step[];
  maps: StepMap[];
  message?: string;
}

interface Span {
  from: number;
  to: number;
  commitId: string | null;
}

interface TrackState {
  commits: Commit[];
  blameMap: Span[];
  uncommittedSteps: Step[];
  uncommittedMaps: StepMap[];
}

function createTrackState(
  blameMap: Span[],
  commits: Commit[] = [],
  uncommittedSteps: Step[] = [],
  uncommittedMaps: StepMap[] = []
): TrackState {
  return {
    blameMap,
    commits,
    uncommittedSteps,
    uncommittedMaps,
  };
}

function createCommit(time: number, steps: Step[], maps: StepMap[], message?: string): Commit {
  return {
    id: nanoid(),
    time,
    steps,
    maps,
    message,
  };
}

function createSpan(from: number, to: number, commitId: string | null): Span {
  return { from, to, commitId };
}

function insertIntoBlameMap(spanMap: Span[], from: number, to: number, commit: Commit) {
  if (from >= to) return spanMap;
  const _spanMap: Span[] = spanMap.slice();
  let _from = from;
  let _to = to;
  let pos = 0;
  let next: Span;
  for (; pos < _spanMap.length; pos++) {
    next = _spanMap[pos];
    if (next.commitId === commit.id) {
      if (next.to >= _from) break;
    } else if (next.to > _from) {
      // Different commit, not before
      if (next.from < _from) {
        // Sticks out to the left (loop below will handle right side)
        let left = createSpan(next.from, _from, next.commitId);
        if (next.to > _to) {
          _spanMap.splice(pos++, 0, left);
        } else {
          _spanMap[pos++] = left;
        }
      }
      break;
    }
  }

  while ((next = _spanMap[pos])) {
    if (next.commitId === commit.id) {
      if (next.from > _to) break;
      _from = Math.min(_from, next.from);
      _to = Math.max(_to, next.to);
      _spanMap.splice(pos, 1);
    } else {
      if (next.from >= _to) {
        break;
      }
      if (next.to > _to) {
        _spanMap[pos] = createSpan(_to, next.to, next.commitId);
        break;
      } else {
        _spanMap.splice(pos, 1);
      }
    }
  }

  _spanMap.splice(pos, 0, createSpan(_from, _to, commit.id));

  return _spanMap;
}

function updateBlameMap(spanMap: Span[], transform: Transform, commit: Commit) {
  const result: Span[] = [];
  const mapping = transform.mapping;

  for (let span of spanMap) {
    const from = mapping.map(span.from, 1);
    const to = mapping.map(span.to, -1);
    if (from < to) result.push(createSpan(from, to, span.commitId));
  }

  for (let i = 0; i < mapping.maps.length; i++) {
    const map = mapping.maps[i];
    const after = mapping.slice(i + 1);
    map.forEach((_s, _e, start, end) => {
      insertIntoBlameMap(result, after.map(start, 1), after.map(end, 1), commit);
    });
  }

  return result;
}

function applyTransform(transform: Transform, tracker: TrackState): TrackState {
  const inverted = transform.steps.map((step, i) => step.invert(transform.docs[i]));
  const blameMap = updateBlameMap(tracker.blameMap, transform, tracker.commits.length);
  return createTrackState(
    blameMap,
    tracker.commits,
    tracker.uncommittedSteps.concat(inverted),
    tracker.uncommittedMaps.concat(transform.mapping.maps)
  );
}

function applyCommit(time: number, tracker: TrackState, message?: string) {
  if (tracker.uncommittedSteps.length == 0) return tracker;
  const commit = createCommit(time, tracker.uncommittedSteps, tracker.uncommittedMaps, message);
  return createTrackState(tracker.blameMap, tracker.commits.concat(commit), [], []);
}

export function createIndexedDBWriterPlugin() {
  const key = new PluginKey("indexed-db-writer");

  return new Plugin<TrackState>({
    key,
    state: {
      init: (_m, instance) => {
        return createTrackState([createSpan(0, instance.doc.content.size, null)]);
      },
      apply: (tr, tracked) => {
        let _tracked: TrackState = tracked;
        if (tr.docChanged) _tracked = applyTransform(tr, _tracked);
        const commitMessage = false;
        if (commitMessage) _tracked = applyCommit(tr.time, _tracked, "some");
        return _tracked;
      },
    },
  });
}
